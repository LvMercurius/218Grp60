# -*- coding: utf-8 -*-
"""group_project (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gx2X3HhgHD7zYApn8I72U_IWupOj5lxk

Config main parameters for TSP problem and each algorithm (Easy to adjust)
"""

import argparse

parser = argparse.ArgumentParser(description='Configuration file')
arg_lists = []


def add_argument_group(name):
    arg = parser.add_argument_group(name)
    arg_lists.append(arg)
    return arg

# TSP Data
data_arg = add_argument_group('Data')
data_arg.add_argument('--city_num', type=int, default=15, help='city num')
data_arg.add_argument('--pos_dimension', type=int, default=2, help='city position') # coordinate

data_arg.add_argument('--gen_num', type=int, default=300, help='generation num') # iteration

# Genetic Algo Data
data_arg.add_argument('--individual_num', type=int, default=100, help='individual num')
data_arg.add_argument('--mutate_prob', type=float, default=0.02, help='probability of mutate') # mutation prob

# Ant Colony Algo Data
data_arg.add_argument('--ant_num', type=int, default=15, help='number of ants')
data_arg.add_argument('--alpha', type=float, default=1.0, help='alpha')
data_arg.add_argument('--beta', type=float, default=3.0, help='beta')
data_arg.add_argument('--evaporation', type=float, default=0.6, help='Retention after evaporation')

# Simulated Annealing Algo Data
data_arg.add_argument('--initial_temp', type=float, default=1000.0, help='initial temperature')
data_arg.add_argument('--cooling_rate', type=float, default=0.93, help='cooling rate (temperature decay factor per iteration)')
data_arg.add_argument('--stopping_temp', type=float, default=1e-3, help='Minimum temperature threshold to terminate the algorithm')
data_arg.add_argument('--iteration_per_temp', type=int, default=100, help='Number of iterations at each temperature level')


def get_config():
    config, unparsed = parser.parse_known_args()
    return config


def print_ga_config():
    config = get_config()
    print('\n')
    print('Data Config for GA:')
    print('* city num:', config.city_num)
    print('* individual num:', config.individual_num)
    print('* generation num:', config.gen_num)
    print('* probability of mutate:', config.mutate_prob)

def print_ant_config():
    config = get_config()
    print('\n')
    print('Data Config for Ant Colony:')
    print('* city num:', config.city_num)
    print('* ant num:', config.ant_num)
    print('* alpha:', config.alpha)
    print('* beta:', config.beta)
    print('* iteration amount:', config.gen_num)
    print('* evaporation rate:', config.evaporation)

def print_sa_config():
    config = get_config()
    print('\n')
    print('Data Config for Simulated Annealing:')
    print('* city num:', config.city_num)
    print('* initial temperature:', config.initial_temp)
    print('* cooling rate:', config.cooling_rate)
    print('* stopping temperature:', config.stopping_temp)
    print('* iterations per temperature:', config.iteration_per_temp)

"""Generate city coordinates and calculate the distance matrix between cities."""

import numpy as np
import matplotlib.pyplot as plt
import time
import random
import math
import pandas as pd


config = get_config()

# return a distance matrix from the list of city coordinates
def build_dist_mat(input_list):
    n = config.city_num
    dist_mat = np.zeros([n, n])
    for i in range(n):
        for j in range(i + 1, n):
            d = input_list[i, :] - input_list[j, :]
            # calculate the distance
            dist_mat[i, j] = np.linalg.norm(d)
            dist_mat[j, i] = dist_mat[i, j]
    return dist_mat

# draw the map
def plot_city_map(city_pos_list):
    plt.figure()

    plt.scatter(city_pos_list[:, 0], city_pos_list[:, 1], c='yellow', marker='o', label='City')

    for i, (x, y) in enumerate(city_pos_list):
        plt.text(x, y, f"{i+1}", fontsize=12, ha='right', color='black')

    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.title('Generated TSP City Map')
    plt.grid(True)
    plt.tight_layout()

    plt.show()



# get the city position coordinates
city_pos_list = np.random.rand(config.city_num, config.pos_dimension) * 100
city_pos_list = city_pos_list.astype(int)

# call the funciton to calculate and store the distance data
city_dist_mat = build_dist_mat(city_pos_list)

# check output
df = pd.DataFrame(city_dist_mat.round(2),
                  index=range(1, len(city_dist_mat) + 1),
                  columns=range(1, len(city_dist_mat) + 1))
print("City distance matrix:")
plot_city_map(city_pos_list)

"""Genetic Algo Implement"""

gene_len = config.city_num
individual_num = config.individual_num
gen_num = config.gen_num
mutate_prob = config.mutate_prob

class GA:
    def __init__(self, city_dist_mat):
        self.city_dist_mat = city_dist_mat  # Store the provided distance matrix
        self.population = [self.create_random_order() for _ in range(individual_num)]
        self.fitness = [0] * individual_num
        self.record_distance = float('inf')
        self.best_ever = None
        self.current_best = None
        self.min_distances = []

    # Generate a random route (individual) by shuffling city indices.
    def create_random_order(self):
        order = list(range(gene_len))
        random.shuffle(order)
        return order

    # Calculate the total distance of a given route.
    def calc_distance(self, order):
        d = 0
        for i in range(len(order) - 1):
            cityA = order[i]
            cityB = order[i + 1]
            d += self.city_dist_mat[cityA][cityB]  # Use the precomputed distance matrix
        # Return to the starting city
        d += self.city_dist_mat[order[-1]][order[0]]
        return d

    # Calculate the fitness of each individual in the population and find the best individual in the current population
    def calculate_fitness(self):
        current_record = float('inf')
        for i in range(len(self.population)):
            d = self.calc_distance(self.population[i])
            if d < self.record_distance:
                self.record_distance = d
                self.best_ever = self.population[i]
            if d < current_record:
                current_record = d
                self.current_best = self.population[i]
            self.fitness[i] = 1 / (pow(d, 8) + 1)

    # Assign probabilities to the subsequent Roulette Wheel Selection algorithm by normalizing fitness
    def normalize_fitness(self):
        total = sum(self.fitness)
        self.fitness = [f / total for f in self.fitness]

    # Generate the next population using selection, crossover, and mutation.
    def next_generation(self):
        new_population = []
        for _ in range(individual_num):
            #choose individuals
            orderA = self.pick_one(self.population, self.fitness)
            orderB = self.pick_one(self.population, self.fitness)
            #crossover
            order = self.cross_over(orderA, orderB)
            #mutate
            self.mutate(order, mutate_prob)
            new_population.append(order)
        self.population = new_population

    # Randomly select individuals by pervious probabilities
    def pick_one(self, lst, prob):
        index = 0
        r = random.random()
        while r > 0:
            r -= prob[index]
            index += 1
        index -= 1
        return lst[index][:]

    # Perform crossover between two parent routes to produce an offspring.
    def cross_over(self, orderA, orderB):
        child = [None] * len(orderA)

        # randomly choose the crossover point
        start_pos = random.randint(0, len(orderA) - 1)
        end_pos = random.randint(0, len(orderA) - 1)

        # make sure start_pos <= end_pos
        if start_pos > end_pos:
            start_pos, end_pos = end_pos, start_pos

        # cross to generate child
        child[start_pos:end_pos + 1] = orderA[start_pos:end_pos + 1].copy()

        list1 = list(range(end_pos + 1, len(orderB)))
        list2 = list(range(0, start_pos))
        list_index = list1 + list2
        j = 0
        for i in list_index:
            while orderB[j] in child:
                j += 1
            child[i] = orderB[j]
            j += 1

        return child

    # Apply mutation to an individual route with a given probability.
    def mutate(self, order, mutation_rate):
        if random.random() < mutation_rate:
            # randomly choose swap positions
            index1 = random.randint(0, len(order) - 2)
            index2 = random.randint(index1 + 1, len(order) - 1)

            # reversal
            sub_order = order[index1:index2 + 1]
            sub_order.reverse()

            # insert back
            order[index1:index2 + 1] = sub_order

    def train(self):
        for i in range(gen_num):
            self.calculate_fitness()
            self.normalize_fitness()
            self.next_generation()
            # add to record
            self.min_distances.append(self.record_distance)

        self.best_ever.append(self.best_ever[0])
        return self.best_ever, self.min_distances

"""Genetic Algo Evaluation"""

print_ga_config()

ga = GA(city_dist_mat)

end_time_1 = time.time()
result_list, fitness_list = ga.train()
end_time_2 = time.time()

# get the best route cities coordinates and store
result_pos_list = city_pos_list[result_list, :]

# draw the path graph of ga base on coordinates

fig1 = plt.figure()
plt.plot(result_pos_list[:, 0], result_pos_list[:, 1], 'o-r')
plt.title(u"Genetic Algorithm Path")
plt.xlabel(f'Genetic Algorithm running time: {end_time_2 - end_time_1:.5f} seconds.')

# draw the fitness graph
fig2 = plt.figure()
ga_final_length = fitness_list[-1]
plt.plot(fitness_list, color='red')
plt.title(u"Genetic Algorithm Fitness (Path Length)")
plt.xlabel(f'Generation\nThe final length is: {ga_final_length:.2f}')
plt.ylabel('Fitness (Length)')
plt.tight_layout()
plt.grid(True)

"""Ant Colony Algo Implement"""

num_city = config.city_num
num_ant = config.ant_num
iteration = config.gen_num
alpha = config.alpha
beta = config.beta
evaporation = config.evaporation

class AntColony:
    def __init__(self, city_dist_mat):
        self.city_dist_mat = city_dist_mat
        self.pheromone_table = np.ones((num_city, num_city))
        self.eta_table = 1.0 / (self.city_dist_mat + np.diag([1e10] * num_city))
        self.population = [self.create_random_path() for _ in range(num_ant)]
        self.fitness = [0] * num_ant
        self.record_distance = float('inf')
        self.best_ever = None
        self.current_best = None
        self.min_distances = []

    # Generate a random route (initial solution) for an ant.
    def create_random_path(self):
        order = list(range(num_city))
        random.shuffle(order)
        return order

    # Calculate the total distance of a given route.
    def calc_distance(self, order):
        d = 0
        for i in range(len(order) - 1):
            cityA, cityB = order[i], order[i + 1]
            d += self.city_dist_mat[cityA][cityB]
        d += self.city_dist_mat[order[-1]][order[0]]
        return d

    # Calculate the fitness of each individual in the population and find the best individual in the current population
    def calculate_fitness(self):
        current_record = float('inf')
        for i in range(num_ant):
            d = self.calc_distance(self.population[i])
            if d < self.record_distance:
                self.record_distance = d
                self.best_ever = self.population[i]
            if d < current_record:
                current_record = d
                self.current_best = self.population[i]
            self.fitness[i] = 1 / (d + 1)

    # Assign probabilities to the subsequent Roulette Wheel Selection algorithm by normalizing fitness
    def normalize_fitness(self):
        total = sum(self.fitness)
        self.fitness = [f / total for f in self.fitness]

    # Perform roulette wheel selection to choose the next city.
    def select_path(self, pheromone, eta):
        probabilities = pheromone * (eta ** beta)
        probabilities /= probabilities.sum()
        return np.random.choice(range(len(probabilities)), p=probabilities)

    # Construct new paths for the ant population based on pheromone levels and heuristic information.
    def construct_new_solutions(self):
        new_population = []
        for _ in range(num_ant):
            visited = []
            current_city = random.randint(0, num_city - 1)
            visited.append(current_city)

            for _ in range(num_city - 1):
                unvisited = [c for c in range(num_city) if c not in visited]
                pheromone = np.array([self.pheromone_table[current_city][c] for c in unvisited])
                eta = np.array([self.eta_table[current_city][c] for c in unvisited])
                next_city = unvisited[self.select_path(pheromone, eta)]
                visited.append(next_city)
                current_city = next_city

            visited.append(visited[0])
            new_population.append(visited)

        self.population = new_population

    # Update the pheromone levels based on the best paths found.
    def update_pheromones(self):
        self.pheromone_table *= evaporation  # Evaporate pheromones
        for i in range(num_ant):
            for j in range(num_city):
                cityA, cityB = self.population[i][j], self.population[i][j + 1]
                self.pheromone_table[cityA][cityB] += 1 / self.calc_distance(self.population[i])

    def train(self):
        for _ in range(iteration):
            self.calculate_fitness()
            self.normalize_fitness()
            self.construct_new_solutions()
            self.update_pheromones()
            self.min_distances.append(self.record_distance)

        self.best_ever.append(self.best_ever[0])
        return self.best_ever, self.min_distances

"""Ant Colony Algo Evaluation"""

print_ant_config()

ant_colony = AntColony(city_dist_mat)

end_time_3 = time.time()
result_list, fitness_list = ant_colony.train()
end_time_4 = time.time()

# get the best route cities coordinates and store
result_ant_list = city_pos_list[result_list, :]

# draw path graph
fig3 = plt.figure()
plt.plot(result_ant_list[:, 0], result_ant_list[:, 1], 'o-b')
plt.title(u"Ant Colony Algorithm Path")
plt.xlabel(f"Ant Colony Algorithm running time: {end_time_4 - end_time_3:.5f} seconds.")

# draw length graph
fig4 = plt.figure()
ant_final_length = fitness_list[-1]
plt.plot(fitness_list)
plt.title(u"Ant Colony Algorithm Path Length")
plt.xlabel(f'Iteration\nThe final length is: {ant_final_length:.2f}')
plt.ylabel(f'Length')
plt.tight_layout()
plt.grid(True)

""" Simulated Annealing Algo Implement"""

initial_temp = config.initial_temp
cooling_rate = config.cooling_rate
stopping_temp = config.stopping_temp
iteration_per_temp = config.iteration_per_temp


class SA:
    def __init__(self, city_dist_mat):
        self.city_dist_mat = city_dist_mat
        self.current_solution = self.create_random_order()
        self.best_solution = self.current_solution[:]
        self.record_distance = self.calc_distance(self.best_solution)
        self.current_distance = self.record_distance
        self.history_distances = []
        self.T = initial_temp

    # Generate a random route (initial solution).
    def create_random_order(self):
        order = list(range(config.city_num))
        random.shuffle(order)
        return order

    # Calculate the total distance of a given route.
    def calc_distance(self, order):
        d = 0
        for i in range(len(order) - 1):
            cityA = order[i]
            cityB = order[i + 1]
            d += self.city_dist_mat[cityA][cityB]
        d += self.city_dist_mat[order[-1]][order[0]]
        return d

    # Generate a neighboring solution by randomly applying one of three operations: swap, reverse, insert
    def generate_neighbor(self, order):
      neighbor = order[:]
      index1, index2 = sorted(random.sample(range(len(order)), 2))

      method = random.choice(['swap', 'reverse', 'insert'])

      if method == 'swap':
          neighbor[index1], neighbor[index2] = neighbor[index2], neighbor[index1]
      elif method == 'reverse':
          neighbor[index1:index2+1] = reversed(neighbor[index1:index2+1])
      elif method == 'insert':
          value = neighbor.pop(index2)
          neighbor.insert(index1, value)

      return neighbor

    # Apply the Metropolis criterion to decide whether to accept a new solution (or meets a certain probability).
    def metropolis(self, new_distance):
        if new_distance < self.current_distance:
            return True
        else:
            acceptance_prob = math.exp((self.current_distance - new_distance) / self.T)
            return random.random() < acceptance_prob

    def train(self):
        while self.T > stopping_temp:  # Control temperature decrease
            for _ in range(iteration_per_temp):  # Perform multiple searches per temperature level
                new_solution = self.generate_neighbor(self.current_solution)
                new_distance = self.calc_distance(new_solution)

                if self.metropolis(new_distance):
                    self.current_solution = new_solution
                    self.current_distance = new_distance

                if new_distance < self.record_distance:
                    self.best_solution = new_solution
                    self.record_distance = new_distance

            self.history_distances.append(self.record_distance)

            self.T *= cooling_rate

        self.best_solution.append(self.best_solution[0])

        return self.best_solution, self.history_distances

""" Simulated Annealingn Evaluation"""

print_sa_config()

sa = SA(city_dist_mat)

end_time_5 = time.time()
result_list, fitness_list = sa.train()
end_time_6 = time.time()

result_pos_list = city_pos_list[result_list, :]

fig1 = plt.figure()
plt.plot(result_pos_list[:, 0], result_pos_list[:, 1], 'o-g')
plt.title(u"Simulated Annealing Path")
plt.xlabel(f'Simulated Annealing running time: {end_time_6 - end_time_5:.5f} seconds.')

fig2 = plt.figure()
sa_final_length = fitness_list[-1]
plt.plot(fitness_list, color='green')
plt.title(u"Simulated Annealing Fitness (Path Length)")
plt.xlabel(f'Iteration\nThe final length is: {sa_final_length:.2f}')
plt.ylabel('Path Length')
plt.tight_layout()
plt.grid(True)